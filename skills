#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# ///

import curses
import shutil
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).parent.resolve()
SKILLS_SOURCE_DIR = REPO_ROOT / "output_skills"
GLOBAL_SKILLS_DIR = Path.home() / ".claude" / "skills"
LOCAL_SKILLS_DIR = Path.cwd() / ".claude" / "skills"


def discover_skills():
    if not SKILLS_SOURCE_DIR.exists():
        return {}
    registry = {}
    collisions = []
    for skill_md in sorted(SKILLS_SOURCE_DIR.rglob("SKILL.md")):
        skill_dir = skill_md.parent
        name = skill_dir.name
        if name in registry:
            collisions.append((name, registry[name], skill_dir))
        else:
            registry[name] = skill_dir
    for name, first, duplicate in collisions:
        print(f"!!! COLLISION: skill '{name}' found at both")
        print(f"    {first.relative_to(SKILLS_SOURCE_DIR)}")
        print(f"    {duplicate.relative_to(SKILLS_SOURCE_DIR)}")
        print(f"    Skipping '{name}' entirely — rename one of them to resolve.")
        del registry[name]
    return registry


def skill_source_path(registry, skill_name):
    if skill_name not in registry:
        print(f"Error: Skill '{skill_name}' not found in output_skills/")
        return None
    return registry[skill_name]


def skill_category(registry, skill_name):
    source = registry.get(skill_name)
    if not source:
        return ""
    relative = source.relative_to(SKILLS_SOURCE_DIR)
    parts = relative.parts
    if len(parts) <= 1:
        return ""
    return "/".join(parts[:-1])


def is_installed(registry, skill_name):
    source = skill_source_path(registry, skill_name)
    if not source:
        return False
    target = GLOBAL_SKILLS_DIR / skill_name
    return target.is_symlink() and target.resolve() == source


def is_installed_local(skill_name):
    target = LOCAL_SKILLS_DIR / skill_name
    return target.exists() and target.is_dir()


def install_skill(registry, skill_name):
    source = skill_source_path(registry, skill_name)
    if not source:
        return False
    target = GLOBAL_SKILLS_DIR / skill_name

    if target.exists() or target.is_symlink():
        if target.is_symlink():
            target.unlink()
        else:
            print(f"Error: {target} exists but is not a symlink. Remove manually.")
            return False

    GLOBAL_SKILLS_DIR.mkdir(parents=True, exist_ok=True)
    target.symlink_to(source)
    return True


def uninstall_skill(skill_name):
    target = GLOBAL_SKILLS_DIR / skill_name
    if target.is_symlink():
        target.unlink()
        return True
    elif target.exists():
        print(f"Error: {target} is not a symlink. Remove manually.")
        return False
    return True


def install_skill_local(registry, skill_name):
    source = skill_source_path(registry, skill_name)
    if not source:
        return False
    target = LOCAL_SKILLS_DIR / skill_name

    if target.exists():
        shutil.rmtree(target)

    LOCAL_SKILLS_DIR.mkdir(parents=True, exist_ok=True)
    shutil.copytree(source, target)
    return True


def uninstall_skill_local(skill_name):
    target = LOCAL_SKILLS_DIR / skill_name
    if target.exists() and target.is_dir():
        shutil.rmtree(target)
        return True
    elif target.exists():
        print(f"Error: {target} is not a directory. Remove manually.")
        return False
    return True


def cli_status():
    registry = discover_skills()
    if not registry:
        print("No skills found in output_skills/")
        return

    current_category = None
    for name in sorted(registry, key=lambda n: (skill_category(registry, n), n)):
        category = skill_category(registry, name) or "(uncategorized)"
        if category != current_category:
            if current_category is not None:
                print()
            print(f"  {category}/")
            current_category = category
        status = "installed" if is_installed(registry, name) else "not installed"
        print(f"    {name:<28} {status}")


def cli_status_local():
    registry = discover_skills()
    if not registry:
        print("No skills found in output_skills/")
        return

    print(f"Local skills ({LOCAL_SKILLS_DIR}):")
    current_category = None
    for name in sorted(registry, key=lambda n: (skill_category(registry, n), n)):
        category = skill_category(registry, name) or "(uncategorized)"
        if category != current_category:
            if current_category is not None:
                print()
            print(f"  {category}/")
            current_category = category
        status = "installed" if is_installed_local(name) else "not installed"
        print(f"    {name:<28} {status}")


def cli_install(skill_name):
    registry = discover_skills()
    if install_skill(registry, skill_name):
        print(f"Installed '{skill_name}' (global)")
    else:
        sys.exit(1)


def cli_uninstall(skill_name):
    if uninstall_skill(skill_name):
        print(f"Uninstalled '{skill_name}' (global)")
    else:
        sys.exit(1)


def cli_install_all():
    registry = discover_skills()
    for name in sorted(registry):
        if not is_installed(registry, name):
            install_skill(registry, name)
            print(f"Installed '{name}'")


def cli_uninstall_all():
    registry = discover_skills()
    for name in sorted(registry):
        if is_installed(registry, name):
            uninstall_skill(name)
            print(f"Uninstalled '{name}'")


def cli_install_local(skill_name):
    registry = discover_skills()
    if install_skill_local(registry, skill_name):
        print(f"Installed '{skill_name}' (local: {LOCAL_SKILLS_DIR})")
    else:
        sys.exit(1)


def cli_uninstall_local(skill_name):
    if uninstall_skill_local(skill_name):
        print(f"Uninstalled '{skill_name}' (local)")
    else:
        sys.exit(1)


def build_tui_lines(registry):
    lines = []
    current_category = None
    for name in sorted(registry, key=lambda n: (skill_category(registry, n), n)):
        category = skill_category(registry, name) or "(uncategorized)"
        if category != current_category:
            lines.append(("header", category))
            current_category = category
        lines.append(("skill", name))
    return lines


def render_display_lines(tui_lines, registry, skill_indices, selected_pos):
    display = []
    for i, (kind, value) in enumerate(tui_lines):
        if kind == "header":
            if display:
                display.append(("blank", ""))
            display.append(("header", f"  {value}/"))
        else:
            installed = is_installed(registry, value)
            checkbox = "[x]" if installed else "[ ]"
            is_selected = skill_indices[selected_pos] == i
            prefix = "  → " if is_selected else "    "
            display.append(("skill", f"{prefix}{checkbox} {value}", is_selected))
    return display


def find_selected_display_row(display):
    for row, entry in enumerate(display):
        if entry[0] == "skill" and entry[2]:
            return row
    return 0


def interactive_mode(stdscr):
    curses.curs_set(0)
    curses.use_default_colors()

    registry = discover_skills()

    if not registry:
        stdscr.addstr(0, 0, "No skills found in output_skills/. Press any key to exit.")
        try:
            stdscr.getch()
        except KeyboardInterrupt:
            pass
        return

    tui_lines = build_tui_lines(registry)
    skill_indices = [i for i, (kind, _) in enumerate(tui_lines) if kind == "skill"]
    selected_pos = 0
    scroll_offset = 0
    header_rows = 3
    footer_rows = 2
    page_size = 5

    while True:
        stdscr.clear()
        max_rows, max_cols = stdscr.getmaxyx()
        visible_rows = max_rows - header_rows - footer_rows

        stdscr.addstr(0, 0, "Skills Manager (global)")
        stdscr.addstr(1, 0, "─" * 40)

        display = render_display_lines(tui_lines, registry, skill_indices, selected_pos)
        selected_row = find_selected_display_row(display)

        if selected_row < scroll_offset:
            scroll_offset = selected_row
        elif selected_row >= scroll_offset + visible_rows:
            scroll_offset = selected_row - visible_rows + 1

        visible_slice = display[scroll_offset:scroll_offset + visible_rows]
        for row, entry in enumerate(visible_slice):
            if entry[0] == "blank":
                continue
            stdscr.addstr(row + header_rows, 0, entry[1])

        help_text = "↑↓ navigate | PgUp/PgDn scroll | SPACE toggle | a all | n none | q quit"
        stdscr.addstr(max_rows - 1, 0, help_text[:max_cols - 1])
        stdscr.refresh()

        try:
            key = stdscr.getch()
        except KeyboardInterrupt:
            break

        if key == ord("q"):
            break
        elif key == curses.KEY_UP and selected_pos > 0:
            selected_pos -= 1
        elif key == curses.KEY_DOWN and selected_pos < len(skill_indices) - 1:
            selected_pos += 1
        elif key == curses.KEY_PPAGE:
            selected_pos = max(0, selected_pos - page_size)
        elif key == curses.KEY_NPAGE:
            selected_pos = min(len(skill_indices) - 1, selected_pos + page_size)
        elif key == ord(" "):
            idx = skill_indices[selected_pos]
            name = tui_lines[idx][1]
            if is_installed(registry, name):
                uninstall_skill(name)
            else:
                install_skill(registry, name)
        elif key == ord("a"):
            for idx in skill_indices:
                name = tui_lines[idx][1]
                if not is_installed(registry, name):
                    install_skill(registry, name)
        elif key == ord("n"):
            for idx in skill_indices:
                name = tui_lines[idx][1]
                if is_installed(registry, name):
                    uninstall_skill(name)


def print_usage():
    print("Usage:")
    print("  ./skills status              List global skills status")
    print("  ./skills install <name>      Install skill globally (symlink)")
    print("  ./skills install-all         Install all skills globally")
    print("  ./skills uninstall <name>    Uninstall skill globally")
    print("  ./skills uninstall-all       Uninstall all skills globally")
    print("  ./skills toggle              Interactive mode (TUI)")
    print("")
    print("  ./skills local status        List local skills status")
    print("  ./skills local install <name>   Install skill locally (copy)")
    print("  ./skills local uninstall <name> Uninstall skill locally")


def main():
    args = sys.argv[1:]

    if not args:
        print_usage()
    elif args[0] == "status":
        cli_status()
    elif args[0] == "install-all":
        cli_install_all()
    elif args[0] == "uninstall-all":
        cli_uninstall_all()
    elif args[0] == "install" and len(args) == 2:
        cli_install(args[1])
    elif args[0] == "uninstall" and len(args) == 2:
        cli_uninstall(args[1])
    elif args[0] == "global" and len(args) >= 2:
        if args[1] == "status":
            cli_status()
        elif args[1] == "install" and len(args) == 3:
            cli_install(args[2])
        elif args[1] == "uninstall" and len(args) == 3:
            cli_uninstall(args[2])
        else:
            print_usage()
            sys.exit(1)
    elif args[0] == "local" and len(args) >= 2:
        if args[1] == "status":
            cli_status_local()
        elif args[1] == "install" and len(args) == 3:
            cli_install_local(args[2])
        elif args[1] == "uninstall" and len(args) == 3:
            cli_uninstall_local(args[2])
        else:
            print_usage()
            sys.exit(1)
    elif args[0] in ("toggle", "on", "off"):
        curses.wrapper(interactive_mode)
    else:
        print_usage()
        sys.exit(1)


if __name__ == "__main__":
    main()
